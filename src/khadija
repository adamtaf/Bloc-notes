package service;

import dao.CsvNoteDAO;
import model.Note;

import java.io.IOException;
import java.time.LocalDateTime;
import java.util.*;
import java.util.concurrent.atomic.AtomicLong;
import java.util.concurrent.locks.ReentrantLock;
import java.util.stream.Stream;

public class NoteService {
    private final List<Note> notesInMemory = new ArrayList<>();
    private final Map<String, List<Note>> indexParTag = new HashMap<>();
    private final ReentrantLock lock = new ReentrantLock();
    private final AtomicLong idGen = new AtomicLong(1);

    private final CsvNoteDAO csvDao;
    private final Set<Long> dirty = new HashSet<>();

    public NoteService(CsvNoteDAO csvDao) throws IOException {
        this.csvDao = csvDao;

        // Charger les notes CSV au d√©marrage
        List<Note> loaded = csvDao.importer();
        for (Note n : loaded) {
            notesInMemory.add(n);
            indexNote(n);
            if (n.getId() != null) idGen.updateAndGet(v -> Math.max(v, n.getId() + 1));
        }
    }

    public Note createNote(String titre, String contenu, Set<String> tags) {
        lock.lock();
        try {
            Note n = new Note();
            n.setId(idGen.getAndIncrement());
            n.setTitre(titre);
            n.setContenu(contenu);
            if (tags != null) n.setTags(tags);
            notesInMemory.add(n);
            indexNote(n);
            markDirty(n.getId());
            saveNotesToCsv();
            return n;
        } finally { lock.unlock(); }
    }

    public void updateNote(Note note) {
        lock.lock();
        try {
            Optional<Note> opt = notesInMemory.stream().filter(n -> Objects.equals(n.getId(), note.getId())).findFirst();
            if (!opt.isPresent()) throw new RuntimeException("Note introuvable: " + note.getId());
            Note existing = opt.get();
            existing.setTitre(note.getTitre());
            existing.setContenu(note.getContenu());
            existing.setTags(note.getTags());
            existing.touch();
            rebuildIndex();
            markDirty(existing.getId());
            saveNotesToCsv();
        } finally { lock.unlock(); }
    }

    public void deleteNote(Long id) {
        lock.lock();
        try {
            boolean removed = notesInMemory.removeIf(n -> Objects.equals(n.getId(), id));
            if (!removed) throw new RuntimeException("Note introuvable: " + id);
            rebuildIndex();
            markDirty(id);
            saveNotesToCsv();
        } finally { lock.unlock(); }
    }

    public Stream<Note> getAllNotes() {
        lock.lock();
        try { return new ArrayList<>(notesInMemory).stream(); }
        finally { lock.unlock(); }
    }

    private void indexNote(Note n) {
        if (n.getTags() != null) {
            for (String t : n.getTags()) {
                indexParTag.computeIfAbsent(t, k -> new ArrayList<>()).add(n);
            }
        }
    }

    private void rebuildIndex() {
        indexParTag.clear();
        for (Note n : notesInMemory) indexNote(n);
    }

    private void markDirty(Long id) { if (id != null) dirty.add(id); }

    private void saveNotesToCsv() {
        try { csvDao.exporterCatalogue(notesInMemory); }
        catch (IOException e) { e.printStackTrace(); }
    }

    public List<Note> findByTag(String tag) {
        lock.lock();
        try { return indexParTag.getOrDefault(tag, Collections.emptyList()); }
        finally { lock.unlock(); }
    }
}
